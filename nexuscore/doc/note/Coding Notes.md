# 在 Go 中，为结构体定义方法时选择传入指针接收器（*T）还是值接收器（T），取决于方法的功能需求和结构体的特性。以下是具体的判断依据和示例：  
1.  若方法需要修改结构体的字段 → 必须用指针接收器
2.  若结构体较大 → 建议用指针接收器
3.  若方法需要实现某个接口，且接口方法可能修改状态 → 统一用指针接收器  
4. 若结构体是 “不可变的”（字段仅读取，不修改） → 可选用值接收器
5. 一致性原则：同一结构体的方法应统一接收器类型

# fmt.Printf()中'q'使用场景
1. 调试时打印包含特殊字符的字符串（确保换行、制表符等可见）
2. 生成符合 JSON、Go 源码等格式要求的字符串（自动处理引号转义）
2. 避免字符串中的特殊字符干扰输出格式

# 定义函数内部定义接口
将 c接口定义在函数内部（而非包级别的公开接口），是一种封装设计，主要出于以下几个原因：
func Cause(err error) error {
	type causer interface {
		Cause() error
	}

	for err != nil {
		cause, ok := err.(causer)
		if !ok {
			break
		}

		if cause.Cause() == nil {
			break
		}

		err = cause.Cause()
	}
	return err
}
将 causer 接口定义在 Cause 函数内部（而非包级别的公开接口），是一种封装设计，主要出于以下几个原因：
1. 接口仅用于函数内部逻辑，无需暴露
causer 接口的唯一作用是在 Cause 函数内部进行类型断言，判断错误是否实现了 Cause() error 方法，进而追溯错误链。它是函数实现细节的一部分，而非需要外部依赖的公开接口。
如果将 causer 定义为包级别的公开接口，会给使用者传递不必要的信息（“你需要显式实现这个接口”），但实际上：
对于自定义错误类型（如 withMessage、withCode），只需在内部实现 Cause() error 方法即可，无需显式声明 “实现了 causer 接口”（Go 语言的接口实现是隐式的）。
外部使用者无需知道 causer 接口的存在，只需通过 Cause 函数获取根错误即可。
2. 避免接口污染，保持包的简洁性
一个包的公开接口（如类型、函数、变量）应尽可能精简，只暴露必要的功能。如果将 causer 定义为公开接口，会增加包的接口复杂度，可能导致：
使用者误解其用途，尝试直接依赖 causer 接口进行错误处理（而非通过 Cause 函数）。
未来修改 causer 接口时（如增加方法），会破坏外部依赖，违反 “最小惊讶原则”。
将其定义在函数内部，可确保它是一个 “私有细节”，不会被外部感知，也不会影响包的兼容性。
3. 明确接口的作用域：仅服务于 Cause 函数
causer 接口的设计目标非常单一：仅用于 Cause 函数内部的错误链追溯。将其定义在函数内部，能清晰标记其作用域，避免被其他函数误用。
例如，若包中还有其他函数（如 Is、As 等错误判断函数），它们可能需要不同的接口（如判断错误类型的接口），将 causer 限制在 Cause 函数内，可避免接口混乱。
4. 符合 Go 语言的 “最小暴露” 原则
Go 语言鼓励 “最小暴露”：只公开必要的 API，隐藏实现细节。这种设计有以下好处：
降低使用者的认知负担：无需理解内部接口，只需关注 Cause 函数的输入输出。
提高包的可维护性：内部接口的修改不会影响外部代码，便于后续优化实现（如调整 causer 接口的定义）。