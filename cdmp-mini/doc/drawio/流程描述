客户端发起请求 → GET /v1/users?page=1&limit=10（带分页参数）
    ↓
【Control层】解析请求（user.Controller.List）
    对象：UserController（控制器实例）
    方法：List(c *gin.Context)
    操作：
      1. 绑定请求参数到模型 → var r metav1.ListOptions; c.ShouldBindQuery(&r)
      2. 调用Service层 → users, err := u.srv.Users().List(c, r)
    模型：metav1.ListOptions（分页/筛选参数模型）
    ↓（传递metav1.ListOptions模型）
【Service层】处理业务逻辑（v1.userService.List）
    对象：userService（服务实例，实现UserSrv接口）
    方法：List(ctx context.Context, opts metav1.ListOptions)
    操作：
      1. 调用Store层查询数据 → users, err := u.store.Users().List(ctx, opts)
      2. 处理数据（如并行组装用户信息）→ 用sync.WaitGroup和sync.Map处理
    模型：metav1.ListOptions（入参）、*v1.UserList（Store返回的用户列表模型）
    ↓（传递metav1.ListOptions模型）
【Store层】操作数据库（store/mysql.users.List）
    对象：users（Store实例，实现UserStore接口）
    方法：List(ctx context.Context, opts metav1.ListOptions)
    操作：
      1. 执行数据库查询 → 基于opts分页查询users表
      2. 映射数据库记录到模型 → 将查询结果转换为*v1.UserList
    模型：metav1.ListOptions（入参）、*v1.UserList（包含多个*v1.User模型）
    ↓（SQL查询）
【数据库】MySQL
    返回：用户表记录（如id、username、nickname等字段）
    ↓（记录映射为模型）
【Store层】返回数据
    返回：*v1.UserList（包含用户数据的模型）
    ↓（传递*v1.UserList模型）
【Service层】处理返回结果
    操作：将Store返回的*v1.UserList加工为前端需要的格式（如过滤敏感字段）
    返回：*v1.UserList（处理后的模型）
    ↓（传递*v1.UserList模型）
【Control层】封装响应
    方法：core.WriteResponse(c, nil, users)
    操作：将*v1.UserList模型序列化为JSON响应
    响应格式：{"items": [{"id": "...", "username": "...", ...}], "total": 100}
    ↓
客户端接收响应 → JSON格式的用户列表数据